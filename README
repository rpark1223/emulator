/*  
 *      README
 *      by Robin Park, Sang Woo Kim 11/20/2017
 *      COMP40 HW6
 */

I. Correctly Implemented:
    A. We believe that we have implemented all parts of the assignment correctly
        , from our um_emulator module which execute the instructions contained
        in a .um file and our segment module, which stores our segmented memory.
II. Design Departures:
    A. We initially designed our interfaces with abstraction only in the back of
        our minds. We thus changed the segments interface by hiding the
        sequences that held our mapped and unmapped segments and hid all the
        functions in our um_emulator module (formerly named the execute module)
        that perform instructions on registers/segments. We also made the
        decision to represent our segments as UArray_Ts in order to more easily
        copy segments as well as get their lengths for our replace_segment
        function.
III. Architecture:
    A. Our um_emulator's run function is called from main in order to run
        the whole program. The um_emulator module utilizes the Bitpack module to
        extract the relevant opcodes, registers, and values from each word read
        from the .um file; it keeps these secrets and uses them to decide which
        instruction to perform on which registers/segments in memory. The
        um_emulator module also hides the secret of how registers and the
        program counter are represented, which is as a C-array of uint32_ts.
        The actual execution of the instructions in memory occurs in our
        segments module, which hides the secret of how our memory is represented
        ; its functions are called by the um_emulator module accordingly. With
        regard to the secret of memory representation, segments hides the fact
        that our segments are represented as UArray_Ts in a Seq_T, and that
        their identifiers are contained in another Seq_T when unmapped.
IV. UM Time:
    A. Our UM ran midmark.um, which we counted to run 85,070,522 instructions,
        in 3.624 seconds, so we believe it would run 50 million instructions in
        2.130 seconds.
V. Unit Tests:
    A. halt.um: Tests the halt instruction with a single halt instruction.
    B. halt_verbose.um: Tests halt instruction by making sure none of the
        subsequent instructions are executed.
 *   C. output.um: All registers are initialized to zero at the start of the
        program, so we expect NULL output from each one.
    D. loadval.um: This test uses the output instruction to determine whether
        the values we load into a given register are actually there.
    E. condition_true.um: Loads a non-zero value into $r[C] so that the value in
        $r[B] is loaded into $r[A] and uses output to test whether the move
        occurred.
    F. condition_false.um: Loads a zero value into $r[C] so that the value in
        $r[B] is not loaded into $r[A] and uses output to test that the move
        did not occur.
    G. add.um: Loads two values into two different registers and uses the output
        instruction to determine whether the add instruction was successful.
    H. multiply.um: Loads two values into two different registers and uses the
        output instruction to determine whether the multiply instruction was
        successful.
    I. add_big.um: Tests that the add instruction will return the sum mod 2^32
        by adding numbers with a sum > 2^32.
    J. multiply_big.um: Tests that the multiply instruction will return the
        product mod 2^32 by multiplying numbers with a product > 32 bits.
    K. divide.um: Loads two values into two different registers and uses the
        output instruction to determine whether the divide instruction was
        successful.
    L. nand.um: Tests the nand instruction by performing the 'and' operation on
        two values, flipping the bits of the result, and using the ouput
        instruction on the final value.
    M. map.um: Maps 32 segments, not including the zero segment, so that the
        identifier of segment 33, aka 33, which is a printable ASCII character,
        can be viewed on standard output using the output instruction.
    N. unmap.um: Maps 50 new segments and unmaps the 40th segment. We re-map the
        40th segment so that the identifier is stored in $r[B], which we can
        view using the output instruction.
    O. segment_store.um: Stores the halt instruction in the zero segment so that
        the program will halt before it reaches the last instruction.
    P. segment_load.um: Stores a value in a given location using segment_store
        and then retrieves that value using segment_load; uses the output
        instruction to test whether the retrieved value is the same as the one
        that was initially stored.
    Q. input.um: Takes an input from standard input, adds 5 to its value, and
        outputs the resulting character. In our program, our input of 'A' should
        return 'F', which has an ascii-value 5 greater than that of 'A'.
    R. load_prog.um: Maps segment 1 and stores instructions in it that should
        load the value 33 into a register, output it, and halt. Tests the
        load_program instruction by calling it to replace the zero segment with
        segment 1 and seeing if the ascii-value of 33 is output and the program
        halts.

* All of these unit tests include a halt instruction at the end, with the
exception of the halt_verbose, segment_store, and load_prog tests

VI. Hours Spent:
    A. Analyzing Assignment: 4
    B. Preparing Design: 4
    C. Solving Problems: 10

N.B.: Our homework and lab submissions were from different accounts, rpark01 and
      skim39 respectively.